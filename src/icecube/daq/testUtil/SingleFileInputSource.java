/**
 * SingleFileInputSource
 * Date: Oct 25, 2005 1:13:46 PM
 * 
 * (c) 2005 IceCube Collaboration
 */
package icecube.daq.testUtil;

import icecube.daq.payload.PayloadReader;

import java.nio.channels.SelectableChannel;
import java.nio.channels.Pipe;
import java.nio.ByteBuffer;
import java.io.IOException;
import java.io.EOFException;
import java.io.File;
import java.util.List;
import java.util.ArrayList;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * @author artur
 * @version $Id: SingleFileInputSource.java,v 1.4 2005/12/01 02:30:05 artur Exp $
 */
public class SingleFileInputSource implements InputSource {

    private Pipe.SinkChannel sinkChannel;
    private Pipe.SourceChannel sourceChannel;
    private Pipe pipe;
    private int sourceID = 0;
    private boolean done = false;
    private PayloadReader payloadReader;
    private List buffers = new ArrayList();

    private final int DONE_SIGNAL = 4;

    private Log log = LogFactory.getLog(SingleFileInputSource.class);

    public SingleFileInputSource(String sourceFileName, int sourceID) throws IOException {

        if (!(new File(sourceFileName).exists())) {
            throw new IllegalArgumentException(sourceFileName + " does not exist.");
        }
        payloadReader = new PayloadReader(sourceFileName);
        payloadReader.open();
        pipe = Pipe.open();
        sinkChannel = pipe.sink();
        sourceChannel = pipe.source();
        sinkChannel.configureBlocking(true);
        sourceChannel.configureBlocking(false);

        this.sourceID = sourceID;
        //bufferCache = new ByteBufferCache(1024);
    }

    /**
     * start processing data by reading them from the source and feeding the other end of the pipe
     *
     * @throws java.io.IOException
     */
    public void startProcessing() throws IOException {
        int header = 0;
        int bytesRead = 1;
        while (bytesRead > 0 && !done) {
            ByteBuffer buf = ByteBuffer.allocate(32000);
            //ByteBuffer buf = bufferCache.acquireBuffer(1024);
            try {
                payloadReader.readNextPayload(buf);
                buf.clear();
                header = buf.getInt(0);
                buf.limit(header);
            } catch (EOFException eofEx) {
                buf.clear();
                buf.limit(DONE_SIGNAL);
                buf.putInt(0, DONE_SIGNAL);
                done = true;
                if (log.isInfoEnabled()) {
                    log.info("END OF FILE from Channel " + sourceID);
                }
                try {
                    payloadReader.close();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
            buffers.add(buf);
            if (buffers.size() == 10000 || done) {
                /*
                while(tempBuffers.size() > 0){
                    bufferCache.returnBuffer((ByteBuffer)tempBuffers.remove(0));
                }
                */
                while (buffers.size() > 0) {
                    buf = (ByteBuffer) buffers.remove(0);
                    header = buf.getInt(0);
                    try {
                        int nWrite = sinkChannel.write(buf);
                        Thread.sleep(100);
                        //tempBuffers.add(buf);
                        if (nWrite != header) {
                            log.error("Payload is " + header + " bytes, but only wrote " + nWrite + " bytes!");
                        } else {
                            if (log.isDebugEnabled()){
                                log.debug("sending a regular payload of length " + header);
                            }
                        }
                    } catch (Exception e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        }
    }

    /**
     * return an array of SelectableChannel(s) generated by this object
     *
     * @return an array of SelectableChannel
     */
    public SelectableChannel getSourceChannel() {
        return sourceChannel;
    }

    /**
     * check to see if the input source is running
     *
     * @return
     */
    public boolean isRunning() {
        if (done) {
            return false;
        }
        return true;
    }

    /**
     * stop processing data
     *
     * @throws IOException
     */
    public void stopProcessing() throws IOException {
        payloadReader.close();
        sinkChannel.close();
        done = true;
    }

    /**
     * set the rate
     *
     * @param rate
     */
    public void setRate(double rate) {
        throw new UnsupportedOperationException("setRate is not supported for this version");
    }

    /**
     * get the rate for this input source
     *
     * @return rate
     */
    public double getRate() {
        throw new UnsupportedOperationException("getRate is not supported for this version");
    }

    /**
     * set the num of doms
     *
     * @param numDoms
     */
    public void setNumDoms(int numDoms) {
        throw new UnsupportedOperationException("setNumDoms is not supported for this version");
    }

    /**
     * get the num of doms for this input source
     *
     * @return numDoms
     */
    public int getNumDoms() {
        throw new UnsupportedOperationException("getNumDoms is not supported for this version");
    }

    /**
     * set source ID
     *
     * @param sourceID
     */
    public void setSourceID(int sourceID) {
        throw new UnsupportedOperationException("setSourceID is not supported for this version");
    }

    /**
     * get the sourceID for this input source
     *
     * @return sourceID
     */
    public int getSourceID() {
        return sourceID;
    }

    /**
     * set the trigger mode
     *
     * @param triggerMode
     */
    public void setTriggerMode(int triggerMode) {
        throw new UnsupportedOperationException("setTriggerMode is not supported for this version");
    }

    /**
     * get the trigger mode for this input source
     *
     * @return triggerMode
     */
    public int getTriggerMode() {
        throw new UnsupportedOperationException("getTriggerMode is not supported for this version");
    }

    /**
     * set payloadType
     *
     * @param payloadType
     */
    public void setPayloadType(String payloadType) {
        throw new UnsupportedOperationException("setPayloadType is not supported for this version");
    }

    /**
     * get payloadType for this input source
     *
     * @return payloadType
     */
    public String getPayloadType() {
        throw new UnsupportedOperationException("getPayloadType is not supported for this version");
    }

    /**
     * set the duration of the process in hours
     *
     * @param hours
     */
    public void setProcessDuration(int hours) {
        throw new UnsupportedOperationException("setProcessDuration is not supported for this version");
    }

    /**
     * get the duration of the process in hours
     *
     * @return an int value
     */
    public int getProcessDuration() {
        throw new UnsupportedOperationException("getProcessDuration is not supported for this version");
    }

    /**
     * Set number of hits
     *
     * @param hits
     */
    public void setNumOfHits(long hits) {
        throw new UnsupportedOperationException("setNumOfHits is not supported for this version");
    }

    /**
     * get the number of hits
     *
     * @return a long value
     */
    public long getNumOfHits() {
        throw new UnsupportedOperationException("getNumOfHits is not supported for this version");
    }
}
