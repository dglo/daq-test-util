/**
 * FileInputSource
 * Date: Sep 14, 2005 9:49:16 AM
 * 
 * (c) 2005 IceCube Collaboration
 */
package icecube.daq.testUtil;

import icecube.daq.payload.PayloadReader;

import java.nio.channels.SelectableChannel;
import java.nio.channels.Pipe;
import java.nio.ByteBuffer;
import java.io.IOException;
import java.io.File;
import java.io.EOFException;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * @author artur
 * @version $Id: FileInputSource.java,v 1.5 2006/01/17 02:29:36 artur Exp $
 */
public class FileInputSource implements InputSource {

    private Pipe.SinkChannel sinkChannel;
    private Pipe.SourceChannel sourceChannel;
    private Pipe pipe;
    private int sourceID = 0;
    private double rate = 0.0;
    private int numDoms = 0;
    private boolean done = false;
    private PayloadReader payloadReader;

    private final int DONE_SIGNAL = 4;

    private Log log = LogFactory.getLog(FileInputSource.class);

    public FileInputSource(String sourceFileName, int sourceID) throws IOException {

        if (!(new File(sourceFileName).exists())){
            throw new IllegalArgumentException(sourceFileName + " does not exist.");
        }
        payloadReader = new PayloadReader(sourceFileName);
        payloadReader.open();
        pipe = Pipe.open();
        sinkChannel = pipe.sink();
        sourceChannel = pipe.source();
        sinkChannel.configureBlocking(true);
        sourceChannel.configureBlocking(false);

        this.sourceID = sourceID;
    }

    /**
     * return an array of SelectableChannel(s) generated by this object
     *
     * @return an array of SelectableChannel
     */
    public SelectableChannel getSourceChannel(){
        return sourceChannel;
    }

    /**
     * start processing data by reading them from the source and feeding the other end of the pipe
     *
     * @throws java.io.IOException
     */
    public void startProcessing() throws IOException{

        ByteBuffer buf = ByteBuffer.allocate(BufferUtil.DEFAULT_BUFFER_BLEN);
        int header = 0;
        try {
            payloadReader.readNextPayload(buf);
            buf.clear();
            header = buf.getInt(0);
            buf.limit(header);
        } catch (EOFException eofEx){
            buf.clear();
            buf.limit(DONE_SIGNAL);
            buf.putInt(0, DONE_SIGNAL);
            done = true;
            if (log.isInfoEnabled()){
                log.info("END OF FILE from Channel " + sourceID);
            }
            try {
                payloadReader.close();
            } catch(IOException e){
                throw new RuntimeException(e);
            }
        } catch (Exception e){
            throw new RuntimeException(e);
        }
        try {
            int nWrite = sinkChannel.write(buf);
            if (nWrite != header) {
                log.error("Payload is " + header + " bytes, but only wrote " + nWrite + " bytes!");
            }
        } catch(Exception e){
            throw new RuntimeException(e);
        }
    }

    /**
     * check to see if the input source is running
     * @return
     */
    public boolean isRunning(){
        if (done){
            return false;
        }
        return true;
    }

    /**
     * stop processing data
     *
     * @throws IOException
     */
    public void stopProcessing() throws IOException{
        payloadReader.close();
        sinkChannel.close();
        done = true;
    }

    /**
     * set the rate
     * @param rate
     */
    public void setRate(double rate){
        this.rate = rate;
    }

    /**
     * get the rate for this input source
     * @return rate
     */
    public double getRate(){
        return rate;
    }

    /**
     * set the num of doms
     * @param numDoms
     */
    public void setNumDoms(int numDoms){
        this.numDoms = numDoms;
    }

    /**
     * get the num of doms for this input source
     * @return numDoms
     */
    public int getNumDoms(){
        return numDoms;
    }

    /**
     * set source ID
     * @param sourceID
     */
    public void setSourceID(int sourceID){
        this.sourceID = sourceID;
    }

    /**
     * get the sourceID for this input source
     * @return sourceID
     */
    public int getSourceID(){
        return sourceID;
    }

    /**
     * set the trigger mode
     * @param triggerMode
     */
    public void setTriggerMode(int triggerMode){
        throw new UnsupportedOperationException("setTriggerMode is not supported for this version");
    }

    /**
     * get the trigger mode for this input source
     * @return triggerMode
     */
    public int getTriggerMode(){
        throw new UnsupportedOperationException("getTriggerMode is not supported for this version");
    }

    /**
     * set payloadType
     * @param payloadType
     */
    public void setPayloadType(String payloadType){
        throw new UnsupportedOperationException("setPayloadType is not supported for this version");
    }

    /**
     * get payloadType for this input source
     * @return payloadType
     */
    public String getPayloadType(){
        throw new UnsupportedOperationException("getPayloadType is not supported for this version");
    }

    /**
     * set the duration of the process in hours
     * @param hours
     */
    public void setProcessDuration(int hours){
        throw new UnsupportedOperationException("setProcessDuration is not supported for this version");
    }

    /**
     * get the duration of the process in hours
     * @return an int value
     */
    public int getProcessDuration(){
        throw new UnsupportedOperationException("getProcessDuration is not supported for this version");
    }

     /**
     * Set number of hits
     * @param hits
     */
    public void setNumOfHits(long hits){
        throw new UnsupportedOperationException("setNumOfHits is not supported for this version");
    }

    /**
     * get the number of hits
     * @return a long value
     */
    public long getNumOfHits(){
        throw new UnsupportedOperationException("getNumOfHits is not supported for this version"); 
    }
}
